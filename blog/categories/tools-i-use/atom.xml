<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tools-i-use | @Lenciel]]></title>
  <link href="http://lenciel.cn/blog/categories/tools-i-use/atom.xml" rel="self"/>
  <link href="http://lenciel.cn/"/>
  <updated>2016-02-21T20:15:41+08:00</updated>
  <id>http://lenciel.cn/</id>
  <author>
    <name><![CDATA[Lenciel Li]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何使用Chrome自定义搜索]]></title>
    <link href="http://lenciel.cn/2016/02/how-can-everybody-use-chrome/"/>
    <updated>2016-02-20T11:53:34+08:00</updated>
    <id>http://lenciel.cn/2016/02/how-can-everybody-use-chrome</id>
    <content type="html"><![CDATA[<p>这篇文章讨论的办法，主要是结合使用&#8221;Google搜索定制化&#8221;+&ldquo;Chrome浏览器快捷搜索入口&#8221;，鉴于众所周知的原因，如果你不会翻墙可能不能直接使用。</p>

<p>但是鉴于国内搜索引擎功能上多少都有借鉴Google，浏览器多少都有借鉴Chrome，所以这里讨论的办法也许用其他&#8221;搜索&#8221;+&ldquo;浏览器&#8221;组合也可以使用。只是我们都知道国内搜索引擎索引出来的结果有多离奇，所以效果上可能会打一些折扣。</p>

<a name="Google..............."></a>
<h3>Google搜索定制化</h3>

<p>google的搜索语法一般用户可能不太知道，但其实对找东西很有用。大家都可以常用的有：</p>

<a name="L.."></a>
<h4>&ldquo;&rdquo;</h4>

<p>把搜索词放在双引号中，代表完全匹配搜索，也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配。</p>

<p>比如搜索代码里面的抛出的错误，你直接把错误行扔进去，往往不如加上引号来完全匹配准确。</p>

<a name="filetype"></a>
<h4>filetype</h4>

<p>用于搜索特定文件格式，比如搜索<code>filetype:pdf</code>，那么就只返回所有包含关键词的pdf文件。</p>

<a name="site"></a>
<h4>site</h4>

<p>用来搜索某个域名下的所有文件，比如在百度网盘里面搜索名字包含Hadoop的文件，就可以搜索<code>Hadoop site:pan.baidu.com</code>。</p>

<a name="L-"></a>
<h4>-</h4>

<p>代表搜索不包含减号后面的词的页面。使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。</p>

<a name="L."></a>
<h4>*</h4>

<p>是常用的通配符，也可以用在搜索中，代表任何文字。</p>

<p>熟练掌握并且综合使用上面这些语法，你就可以非常快速地找到你需要的东西了。</p>

<a name="L.............................."></a>
<h3>浏览器的搜索快捷入口</h3>

<p>Chrome为你提供了快捷方式来使用搜索。按<code>Cmd+L</code>（Windows平台大概是<code>Ctrl+L</code>）进入地址栏，然后输入要搜索的内容，回车，就会使用你的默认搜索引擎进行搜索。</p>

<p>假如你要切换一个搜索引擎，比如你的默认引擎是Google，偶尔你需要用百度来搜索，只需要在地址栏里面先敲<code>baidu</code>，然后按<code>Tab</code>键，然后输入你需要搜索的关键字并回车，就可以了。</p>

<p>Chrome里面你可以这样使用的搜索引擎数量其实是远超你想象的。</p>

<p>在地址栏里面敲入<code>chrome://settings/</code>，然后进入搜索引擎的配置你就可以看到它们：</p>

<p><img src="/downloads/images/2016_02/manage_search_engine.png" title="Don't touch me..." alt="Vhost threshold" /></p>

<a name="L...................................."></a>
<h3>自定义搜索的快捷方式创建</h3>

<p>一旦开始使用自定义搜索，你就会发现有些搜索使用频率相当高。</p>

<p>比如之前提到的在百度盘里面搜索某个文件。</p>

<p>再比如在<a href="http://quora.com/">Quora</a>或者<a href="http://zhihu.com">知乎</a>里面搜索包含某个关键字的问答。</p>

<p>再比如在<a href="https://pinboard.com">Pinboard</a>里面搜索你自己收藏的书签。</p>

<p>这个时候你只需要在搜索引擎的配置列表的最下方添加一个自定义的搜索引擎：</p>

<p><img src="/downloads/images/2016_02/custom_search_engine.png" title="Don't touch me..." alt="Vhost threshold" /></p>

<p>比如我们添加一个<code>Keyword</code>是<code>panb</code>的搜索引擎，它的URL是：</p>

<pre><code>https://www.google.com.hk/search?q=%s+site%3Apan.baidu.com
</code></pre>

<p>注意URL这个参数需要做<a href="https://docs.oracle.com/javase/7/docs/api/java/net/URLEncoder.html">urlencode</a>，所以空格变成了<code>+</code>，<code>site:pan.baidu.com</code>变成了<code>site%3Apan.baidu.com</code>。如果你不知道<code>urlencode</code>怎么做，有个简单的办法就是先到Google上完成一次搜索，然后从地址栏上面复制粘贴下来。</p>

<p>定义好了以后，你只需要在地址栏里面输入Keyword（panb），然后按<code>Tab</code>键，再输入你需要查找的资源，回车，就可以看到结果了：</p>

<p><video width='640' height='320' preload='none' controls poster=''><source src='http://lenciel.cn/downloads/video/chrome_custom_search.mp4">http://lenciel.cn/downloads/video/chrome_custom_search.mp4</a>&#8217; ></video></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[提取微信语音消息]]></title>
    <link href="http://lenciel.cn/2015/12/extract-audio-message-from-wechat/"/>
    <updated>2015-12-24T13:05:21+08:00</updated>
    <id>http://lenciel.cn/2015/12/extract-audio-message-from-wechat</id>
    <content type="html"><![CDATA[<a name="Why."></a>
<h3>Why?</h3>

<p>Why not?</p>

<a name="How."></a>
<h3>How?</h3>

<a name="L................................."></a>
<h4>导出原始微信的音频消息</h4>

<ul>
<li>使用iTunes创建一个不加密备份</li>
<li>导出备份中的微信应用文件夹（可以使用iExplorer试用版）</li>
<li>找到你需要转换的音频文件所在文件夹</li>
</ul>


<a name="L......silk3...............mp3"></a>
<h4>转换silk3编码音频为mp3</h4>

<p>如果你是mac机器，只需要安装ffmpeg（推荐使用homebrew）然后运行脚本：</p>

<pre><code class="python">    python wechat2mp3.py 待转换音频所在文件夹
</code></pre>

<p>如果你是其他系统，确认你装好了ffmpeg之后，需要<a href="https://github.com/gaozehua/SILKCodec">自己编译SILK解码库</a>。</p>

<a name="Seriously.Why."></a>
<h3>Seriously Why?</h3>

<p>常温常压下我并不需要导出微信的语音，之所以有这个需求是因为蒙爷在三亚经常用微信跟我们唠嗑：</p>

<p><audio controls loop preload><source src="http://lenciel.cn/downloads/audio/mm_voice.mp3"></audio></p>

<p>听到这样销魂的声音你就算不想保存，也想要转发，对不对？</p>

<p>毕竟作为一名中国人，你已经有8个亲戚群了，对不对？</p>

<p>然后微信奇怪的生态圈构建方式就是，各种封闭。</p>

<p>微信公众号是世间少有的不允许外链的媒体，微信客户端是世间少有的不允许导出聊天记录的聊天工具。</p>

<p>它的想法大概是，你珍贵的瞬间都在我这里（微信专门做了“收藏”这个功能让你把这些片段上传到微信的服务器，打着不让它们丢失的旗号），那你就逃不出我的手掌心了。</p>

<a name="Seriously.How."></a>
<h3>Seriously How?</h3>

<p>使用iTunes创建一个不加密的备份，然后连接iExplorer，会看到打开iTunes备份的选项：</p>

<p><img src="/downloads/images/2015_12/extract_wechat_1.png" title="Don't touch me..." alt="Vhost threshold" /></p>

<p>打开后在<code>App</code>文件夹下面导出微信文件夹：</p>

<p><img src="/downloads/images/2015_12/extract_wechat_2.png" title="Don't touch me..." alt="Vhost threshold" /></p>

<p>在导出的文件夹下面有个Audio目录，你可以根据语音消息的数量大概确认需要导出的目录（目录是个hash），然后到<code>DB/MM.sqlite</code>下面去打开<code>Chat_[hash]</code>这个表里面，看看消息来确认：</p>

<p><img src="/downloads/images/2015_12/extract_wechat_3.png" title="Don't touch me..." alt="Vhost threshold" /></p>

<p>二进制查看其中的任意一个文件，可以看到是<a href="https://en.wikipedia.org/wiki/SILK">SILK</a>编码的（skype早期版本包括lync都是使用的这种编码方式）：</p>

<p><img src="/downloads/images/2015_12/extract_wechat_4.png" title="Don't touch me..." alt="Vhost threshold" /></p>

<p>接下来你只需要按照<a href="https://github.com/lenciel/wechat2mp3">repo</a>里面的指导(愿主保佑你是用Mac因为那最简单)来进行文件转换就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Palm4fun Tech Stack Review Part II]]></title>
    <link href="http://lenciel.cn/2015/02/p4f-tech-stack-part-2-others/"/>
    <updated>2015-02-20T14:11:19+08:00</updated>
    <id>http://lenciel.cn/2015/02/p4f-tech-stack-part-2-others</id>
    <content type="html"><![CDATA[<p>距离<a href="http://lenciel.cn/2015/01/p4f-tech-stack-part-1-devops/">上篇</a>略久，主要最近很忙。</p>

<a name="Application..amp..Data"></a>
<h2>Application &amp; Data</h2>

<p>和其他几个提供辅助的部分不同，App/Data这部分基本上就是产品本身了。</p>

<a name="Application.Hosting"></a>
<h3>Application Hosting</h3>

<p><img src="/downloads/images/2015_01/p4f_stack_app_data_1.png" title="Don't touch me..." alt="stack_devops_1" /></p>

<p>我们在选择云的时候，也有试用过“久负盛名”的几家大的。</p>

<ul>
<li>阿里因为性价比的原因直接被我忽略了</li>
<li>AWS显然是成熟度最高的，但是在国内用起来确实比较憋屈，希望他们正式入华后有好转</li>
<li>Google的Compute Engine和Windows Azure都属于开张不久，前者因为有打折劵最终被我用来做了很久的翻墙代理（但是也因为忘记关VPS收到了巨额账单，好在Google还比较厚道免单了）。后者因为在国内有部署，速度非常不错，但是整体比UCloud还是贵了不少。</li>
</ul>


<p>最终我们选择了UCloud，他们的价钱比较公道，服务也做得非常棒。虽然我们机器并不是很多，但是仍然有24小时随叫随到的服务团队在跟，并且服务团队的技术实力在国内的服务提供商里面也非常突出。</p>

<p>平时还有一些抛弃型的原型我会放到Heroku或者Google App Engine上，因为它们用来部署Django应用非常便捷。</p>

<p>我们大多数项目都只是简单的管理后台，用Apache还是Nginx并没有明显区别。因为Apache在大多数OS自带，所以基本上都是以Apache+uwsgi+supervisor来进行部署。</p>

<a name="Languages..amp..Frameworks"></a>
<h3>Languages &amp; Frameworks</h3>

<p><img src="/downloads/images/2015_01/p4f_stack_app_data_2.png" title="Don't touch me..." alt="stack_devops_1" /></p>

<p>这张图再画长一倍也不一定能画完，因为这部分特别是Web前端技术的变动实在是太大了。感觉JavaScript社区换框架、方法论、编译工具甚至是VM就像足球运动员换袜子一样勤。</p>

<p>所以我们的策略一直是不绑定到某个具体框架：那样很容易被绑架。从目前来看：</p>

<ul>
<li>React/Flux最近特别火，由Facebook内部使用并开源（特别是最近推出了React Native）。</li>
<li>AngularJS，火了很长时间，由Google内部使用并开源。目前两个主要版本变动太大嘴炮很多，可以观望到尘埃落定再考虑深入学习。</li>
<li>Backbone是非常不错的客户端MVC框架。</li>
<li>node.js和io.js。目前它们是一样的东西，io.js只是node.js的一个fork（类似于Hudson和Jenkins的关系）。目前可以只学node.js但是得盯着io.js的发展，因为很多原来node.js的主力都在io.js这边。</li>
<li>npm是Javascript目前最主要的package管理工具。目前你还会听说bower但几乎大家都已经确认这是个愚蠢的idea。另外你还会听说jspm，一个很新的系统，非常不错，值得留意。</li>
<li>Browserify使得你可以在browser里面直接使用npm的module，而不仅仅是在server端。完全是一次革命，非常好用。</li>
<li>Gulp和Grunt是build工具（类比Ant/Maven），Gulp更新而且设计上非常成熟，推荐学习和使用Gulp。</li>
<li>express.js是服务器端JS应用开发需要学习的东西。</li>
<li>Meteor是设计非常领先的一个全栈的框架（想想Django），整体上非常酷，目前也很流行。如果你想试试自己的学习能力和承受能力，值得一试。</li>
<li>jQuery之于JavaScript就好比少林寺之于中华武术。每个人都在学，都以为它就可以搞定整个武林，但那是错的。JQuery是用来对DOM做操作的，如果你用它在干别的，你多半错了。</li>
</ul>


<a name="Assets..amp..Media"></a>
<h3>Assets &amp; Media</h3>

<p><img src="/downloads/images/2015_01/p4f_stack_app_data_3.png" title="Don't touch me..." alt="stack_devops_1" /></p>

<p>这方面没什么好说的，一开始我们用的就是UCloud自带的服务。后面为Testbird开发项目的时候接触到了七牛云。不得不吐槽一下七牛云还处于快速增长期，不论是提供的服务的稳定性，还是文档更新的及时性，都还有很多值得提高的地方。</p>

<a name="Data.Storage"></a>
<h3>Data Storage</h3>

<p><img src="/downloads/images/2015_01/p4f_stack_app_data_4.png" title="Don't touch me..." alt="stack_app_data_4" /></p>

<p>数据库我们一般本地开发用SQLite，stage和prod服务器用MySQL。之所以没有选择Postgresql是因为它那些很不错的功能我们在项目里面还没有需要，所以就偷懒选择了自己更熟悉的系统。</p>

<a name="Libraries"></a>
<h3>Libraries</h3>

<p><img src="/downloads/images/2015_01/p4f_stack_app_data_5.png" title="Don't touch me..." alt="stack_app_data_5" /></p>

<p>这张图也是很难画完整的，因为它一直在变。不过我们基本上用ACE封装了一套自己的UI框架，对提高开发效率还是非常有用的。</p>

<a name="Utilities"></a>
<h2>Utilities</h2>

<p><img src="/downloads/images/2015_01/p4f_stack_utilities.png" title="Don't touch me..." alt="stack_utilities" /></p>

<p>都是些中规中矩的选择，因为好的服务都在国内被封堵得比较彻底，不是吗？</p>

<p>比如统计，百度做得和Google还差几个数量级（你见过实时统计有百度那么不实时的么？），但是在国内因为墙的关系常常还是只能用。</p>

<p>再比如SMS网关，国外有大量的类似<a href="https://www.twilio.com/sms/toll-free">Twilio</a>的优质服务，价格便宜，接口良好，但是&hellip;我们都用亿美。</p>

<p>值得一提的是推送消息服务，因为被百度坑过，我们一开始用了我浙大著名创业公司“个推”，结果质量低得还比较离谱。最后好死不死又换到了百度Push：原因还是因为Google原生的Push被墙。</p>

<a name="Business.Tools"></a>
<h2>Business Tools</h2>

<p><img src="/downloads/images/2015_01/p4f_stack_business_tools.png" title="Don't touch me..." alt="stack_devops_1" /></p>

<p>其实Trello和Slack这样的工具用好一个就足以撑起一家中等规模的公司了。可惜因为经常被墙，很多不能自己翻墙的同事或者客户用起来倍感艰辛。</p>

<p>整个公司的任务驱动主要还是靠Jira，知识分享和管理主要是靠Confluence。</p>

<p>阿勒！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Goodbye Palm4fun, and the Tech Stack Review Part I]]></title>
    <link href="http://lenciel.cn/2015/01/p4f-tech-stack-part-1-devops/"/>
    <updated>2015-01-04T14:44:23+08:00</updated>
    <id>http://lenciel.cn/2015/01/p4f-tech-stack-part-1-devops</id>
    <content type="html"><![CDATA[<p><img src="/downloads/images/2015_01/goodbye_palm4fun.png" title="Don't touch me..." alt="goodbye" /></p>

<p>大概两年前，和Bergkamp、194一次计划外的聊天之后，<strike>出于保护直肠的目的</strike>，本座离开了基友密布的<a href="http://www.myriadgroup.com/">Myriad</a>，作为Palm4fun的联合创始人之一，开始捣鼓着自己创业。</p>

<p>在具体的研发工作方面，我主要是负责服务器端的开发。但因为被冠名CTO，我的工作还包括：</p>

<ul>
<li>制定研发流程，管理运作研发团队（很幸运，团队都是气味相投的小伙伴并且平均水平很高）</li>
<li>搭建和维护各种IT系统让大家的工作更加轻松</li>
<li>对各种项目进行技术选型、风险评估和报价</li>
<li>培养有palm4fun自己特色的团队文化</li>
<li>甚至是，设计我们的logo和<a href="http://lenciel.cn/2014/09/logo-test/">T-Shirt</a></li>
</ul>


<p>别误会，并不是和写代码比，我更喜欢做这些事情：我做这些，主要是经过多年的折腾，已经对自己想在什么样的环境里进行软件开发有了自己的体会。所以，我当然愿意花时间和小伙伴们一起，把理想中的工作环境具体到实践。</p>

<p>经过这两年的时间，虽然我们有纯技术团队创业理应遭遇的各种捉襟见肘，但因为整个团队的坚持和付出，在活下来的同时，也完成了一定的技术积累。有一个可喜的现象是，我们自己参与开发孵化的项目，虽然有一些死掉了，但也有一些拿到了几百万的天使投资；而我们作为外包方参与研发的项目，客户都非常认可我们的项目质量和工作方式。很多客户不但和我们确定了长期合作的关系，还积极介绍自己朋友的项目给我们。</p>

<p>新年到来之际，随着我们被<a href="http://www.testbird.com/">Testbird</a>收编，Palm4fun大部分成员即将投入到新公司的各条战线，Palm4fun作为一个组织也就此消亡了。回首这两年，我想说，如果你没有和我一起经历那说了你也不懂我还是不说了&hellip;&hellip;</p>

<p>跨年的时候，茕茕孑立的本座画了张思维导图，主要目的是把过去两年palm4fun的积累整理一下。画出来之后很多朋友希望我分享高清无码图：因为整个图非常大，不太适合在移动设备上看。</p>

<p><img src="/downloads/images/2015_01/p4f_stack_all.png" title="Don't touch me..." alt="stack_all" /></p>

<p>其实在一开始选择这些的时候，基本上就是从运维支撑和测试部署工具、产品开发和数据管理、基础设施和功能模块以及商业工具四个维度出发，所以就拆成四个部分简单过一遍。特别声明：选择的依据和出发点主要是根据个人喜好，包括自己使用的体验以及眼缘，并没有特别的理由。比如我们用Reviewboard不用Phabricator，完全是因为团队中大多数人已经用习惯了。</p>

<a name="Build.Test.Deploy"></a>
<h2>Build/Test/Deploy</h2>

<p><img src="/downloads/images/2015_01/p4f_stack_devops_1.png" title="Don't touch me..." alt="stack_devops_1" /></p>

<ul>
<li>我们没有用Gerrit或者Phabricator的原因是它们功能太多了</li>
<li>Ngrok是做微信接口调试时意外发现的好物</li>
</ul>


<a name="Monitoring"></a>
<h2>Monitoring</h2>

<p><img src="/downloads/images/2015_01/p4f_stack_devops_2.png" title="Don't touch me..." alt="stack_devops_2" /></p>

<ul>
<li>Sentry帮我们在用户找到我们之前找到了很多问题</li>
<li>一开始我们用过Nagios，它的设计也很不错，就是界面太&hellip;</li>
<li>Zabbix帮我们远离主机因为硬盘满了或者内存不够驾崩的场面</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Making Fixture With Factory Boy and Faker]]></title>
    <link href="http://lenciel.cn/2014/12/making-fixture-with-factory-boy-and-faker/"/>
    <updated>2014-12-20T03:14:59+08:00</updated>
    <id>http://lenciel.cn/2014/12/making-fixture-with-factory-boy-and-faker</id>
    <content type="html"><![CDATA[<p>我们在Django项目的开发和测试过程中经常需要mock一些数据作为<a href="https://docs.djangoproject.com/en/1.7/howto/initial-data/">fixture</a>，比较常见的做法是：</p>

<ol>
<li>进行一些操作创建测试数据</li>
<li>使用<code>dumpdata</code>命令导出json格式的数据</li>
<li>以导出的json为模板构造测试数据用<code>loaddata</code>命令导入到数据库</li>
</ol>


<p>这样对于大多数场景也算够用了，但是你总会遇到某一天客户走来说：“我想看看那个报表生成出来啥样，能不能创建两千条记录？”</p>

<p>这种时候你大概你第一反应是把之前那个json搞来copy-paste出两千份数据。但很快你就会意识到那是不行的：要构建一个对象，你常常需要先构建它外键的对象，而实际上线的项目它的数据库结构是非常复杂的（数据库结构图的生成见<a href="http://lenciel.cn/2014/12/integrate-schemaspy-with-sphinx-build-for-django-database-design-visualization/">这里</a>），所以构建两千条记录的工作量会远远超过你的想象：</p>

<p><img src="/downloads/images/2014_12/database_design_visualization.png" title="schemaSpy..." alt="schemaSpy" /></p>

<p>最近本座试用了<a href="https://github.com/rbarrois/factory_boy/">factory boy</a>和<a href="https://github.com/joke2k/faker">faker</a>的组合，感觉还比较好用。</p>

<a name="Factory.Boy"></a>
<h2>Factory Boy</h2>

<p>最开始找这类批量生成测试数据的库，主要考察的是<a href="https://github.com/vandersonmota/model_mommy">Model Mommy</a>和<a href="https://github.com/rbarrois/factory_boy/">Factory Boy</a>。看了一下文档感觉两者的差别并不算很大，但是<a href="http://movie.douban.com/subject/1898357/">Factory Girl</a>里面的<a href="http://movie.douban.com/celebrity/1003485/">Sienna Miller</a>实在是让人过目不忘所以有什么好犹豫的呢？</p>

<p>Factories的文档上说明了基本的用法，需要注意的主要是如何生成有一定依赖关系的一组测试对象。</p>

<a name="L............"></a>
<h3>数据构造</h3>

<p>Factory Boy下的数据构造主要是通过<code>Sequence</code>和<code>Fuzz</code>两个包来完成。</p>

<p><code>Sequence</code>故名思议是顺序生成的，比如你要让生成的数据有规律的用户名和电话号码，这样你看到电话<code>13000000001</code>就是是对应<code>user0001</code>：</p>

<pre><code class="python">
user = Sequence(lambda n: u'user%04d' % n)
phone = Sequence(lambda n: u'1300000%04d' % n)
</code></pre>

<p>而<code>Fuzz</code>则是随机的，主要用来构造像学校、专业或者生日这样的数据：</p>

<pre><code class="python">
card_bank = FuzzyChoice([u'中国银行', u'中国招商银行', u'中国工商银行',
                      u'中国建设银行', u'成都银行'])
major = FuzzyChoice([u'地球物理学', u'大气科学', u'海洋科学', u'力学',
                  u'农业工程', u'环境科学', u'心理学', u'统计学',
                  u'系统科学', u'地矿', u'机械', u'仪器仪表',
                  u'能源动力', u'电气信息', u'土建', u'测绘',
                  u'环境与安全', u'化工与制药', u'交通运输', u'海洋工程;',
                  u'航空航天', u'武器', u'工程力学', u'生物工程',
                  u'公安技术', u'材料科学', u'材料', u'水利',
                  u'林业工程', u'轻工纺织食品', u'电子信息科学', u'其他'])
birthday = FuzzyNaiveDateTime(dt.datetime(1992, 1, 1), dt.datetime(1996, 1, 1))
</code></pre>

<p>当然，有的字段，比如姓名、地址这类通过顺序或者是随机的从某个设定的集合抽取效果都不够理想，后面会看到怎么用<a href="https://github.com/joke2k/faker">faker</a>来构造它们。</p>

<a name="L.................."></a>
<h3>关联对象生成</h3>

<p>关联对象的关系有很多种(1:1, 1:n, n:1, n:n)，主要都是通过组合运用<code>SubFactory</code>和<code>RelatedFactory</code>两者来生成，但具体的构造方式和先构造谁都要以实际情况而定。比如我们有User和Tester这样的1:1的关系：</p>

<pre><code class="python">
class Tester(TimeBaseModel):

    user = models.OneToOneField(User,
                                verbose_name=u'账号',
                                related_name='tester')
    ...
</code></pre>

<p>这里在考虑是在<code>TesterFactory</code>里面把<code>User</code>作为<code>SubFactory</code>来生成，还是在<code>UserFactory</code>里面把<code>Tester</code>作为<code>RelatedFactory</code>来生成，主要就是看先后关系。很显然，在这里我们应该先构造系统里的User：</p>

<pre><code class="python">
class TestUserFactory(UserFactory):
    ...
    tester = RelatedFactory('apps.tester.factories.TesterFactory', 'user')
</code></pre>

<p>这段代码告诉系统，在每个<code>TestUser</code>被构造的时候，用构造出来的<code>user</code>来创建一个1:1的<code>Tester</code>。这个<code>Tester</code>的构造会在<code>user</code>的<code>save</code>之前完成。</p>

<p>然后在<code>Tester</code>的构造过程中你可以直接通过<code>SelfAttribute</code>使用传入的<code>user</code>:</p>

<pre><code class="python">
class TesterFactory(DjangoModelFactory):
    ...
    phone = SelfAttribute('user.phone')
    nick_name = SelfAttribute('user.nick_name')
    creator = SelfAttribute('user')
</code></pre>

<p>再比如，我们的<code>Tester</code>和<code>PlatformTask</code>都会关联到测试任务<code>TesterTask</code>，它们俩看起来都是<code>ForeinKey</code>。</p>

<pre><code class="python">
class TesterTask(TestingDeviceMixin, TimeBaseModel):
    owner = models.ForeignKey(Tester,
                              verbose_name=u'测试人', )

    platform_task = models.ForeignKey(PlatformTask,
                                      verbose_name=u'任务',
                                      related_name=u'tester_tasks')
</code></pre>

<p>但对生成数据而言，我们的目标会是每个<code>Tester</code>在被创建的时候，都给它创建一个以这个<code>Tester</code>为<code>owner</code>的<code>TesterTask</code>，并且给这个<code>TesterTask</code>创建一个关联的<code>PlatformTask</code>。</p>

<p>于是我们的写法就会是，首先在<code>TesterFactory</code>里面使用<code>RelatedFactory</code>来创建<code>TesterTask</code>:</p>

<pre><code class="python">
class TesterFactory(DjangoModelFactory):
    ...
    tester_task = RelatedFactory('apps.tester.factories.TesterTaskFactory', 'owner')
    ...
</code></pre>

<p>然后在<code>TesterTaskFactory</code>里面创建<code>PlatformTask</code>，并且在构造的时候使用传入的<code>owner</code>的参数：</p>

<pre><code class="python">
class TesterTaskFactory(DjangoModelFactory):
    ...
    platform_task = SubFactory('apps.platformtask.factories.PlatformTaskFactory',
                               company=SelfAttribute('..owner.user.company'),
                               owner=SelfAttribute('..owner.user'))
    ...
</code></pre>

<a name="faker"></a>
<h2>faker</h2>

<p>有很多字段，比如姓名、地址这些，纯粹用Fuzz的办法很难做到“贴近真实”。<a href="https://github.com/joke2k/faker">faker</a>就是用来解决这类字段的。</p>

<pre><code class="python">
from faker import Factory
fake = Factory.create()

fake.name()
# 'Lucy Cechtelar'

fake.address()
# "426 Jordy Lodge
#  Cartwrightshire, SC 88120-6700"

fake.text()
# Sint velit eveniet. Rerum atque repellat voluptatem quia rerum. Numquam excepturi
# beatae sint laudantium consequatur. Magni occaecati itaque sint et sit tempore. Nesciunt
# amet quidem. Iusto deleniti cum autem ad quia aperiam.
# A consectetur quos aliquam. In iste aliquid et aut similique suscipit. Consequatur qui
# quaerat iste minus hic expedita. Consequuntur error magni et laboriosam. Aut aspernatur
# voluptatem sit aliquam. Dolores voluptatum est.
# Aut molestias et maxime. Fugit autem facilis quos vero. Eius quibusdam possimus est.
# Ea quaerat et quisquam. Deleniti sunt quam. Adipisci consequatur id in occaecati.
# Et sint et. Ut ducimus quod nemo ab voluptatum.
</code></pre>

<p>这个包最可爱的地方就是支持本地化，比如一个随机的中文姓名可以这么去构造：</p>

<pre><code class="python">
faker = FakerFactory.create('zh_CN')
name = lazy_attribute(lambda x: faker.name())
</code></pre>

<a name="L......fixture"></a>
<h2>生成fixture</h2>

<p>因为<a href="https://github.com/rbarrois/factory_boy/">factory boy</a>和<a href="https://github.com/joke2k/faker">faker</a>主要的作用是在测试里面去mock数据，所以要用它们生成fixture不是那么容易。这是因为Django的整个设计上就很注意避免你把测试的数据写到生产的数据库，所以测试都会在一个在<code>Setup</code>阶段被创建，在<code>TearDown</code>阶段被删除的临时数据库里面进行（我看了一下，在开发版本的Django上已经加了一个<code>--keepdb</code>的参数使得你可以<a href="https://docs.djangoproject.com/en/dev/ref/django-admin/#django-admin-option---keepdb">保留你用来运行测试的数据库了</a>）。</p>

<p>所以我们可以在一个测试的<code>Setup</code>阶段把数据生成后，直接调用<code>dumpdata</code>命令来把数据<code>dump</code>出去：</p>

<pre><code class="python">
def setUp(self):
    company = CompanyFactory.create(id=3)
    TestUserFactory.create(company=company, id=3000)
    TestUserFactory.create_batch(company=company, size=1500)

    #for test_user in test_users:

    create_fixture('tester', 'tester.json')
    create_fixture('account', 'account.json')
</code></pre>

<p>注意，这里在创建的时候指定id主要是为了让初始的id比较大，避免和系统里面已经有的id撞车导致你构造的测试数据在<code>loaddata</code>的时候报错或者覆盖现有数据。</p>

<p>其中，<code>create_fixture</code>函数内容如下：</p>

<pre><code class="python">def create_fixture(app_name, filename):
    buf = StringIO()
    management.call_command('dumpdata', app_name, indent=4, stdout=buf)
    buf.seek(0)
    with open(filename, 'w') as f:
        f.write(buf.read().encode('utf-8'))
</code></pre>
]]></content>
  </entry>
  
</feed>
