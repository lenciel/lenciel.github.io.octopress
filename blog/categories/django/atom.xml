<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Django | @Lenciel]]></title>
  <link href="http://lenciel.cn/blog/categories/django/atom.xml" rel="self"/>
  <link href="http://lenciel.cn/"/>
  <updated>2015-03-07T23:49:36+08:00</updated>
  <id>http://lenciel.cn/</id>
  <author>
    <name><![CDATA[Lenciel Li]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Making Fixture With Factory Boy and Faker]]></title>
    <link href="http://lenciel.cn/2014/12/making-fixture-with-factory-boy-and-faker/"/>
    <updated>2014-12-20T03:14:59+08:00</updated>
    <id>http://lenciel.cn/2014/12/making-fixture-with-factory-boy-and-faker</id>
    <content type="html"><![CDATA[<p>我们在Django项目的开发和测试过程中经常需要mock一些数据作为<a href="https://docs.djangoproject.com/en/1.7/howto/initial-data/">fixture</a>，比较常见的做法是：</p>

<ol>
<li>进行一些操作创建测试数据</li>
<li>使用<code>dumpdata</code>命令导出json格式的数据</li>
<li>以导出的json为模板构造测试数据用<code>loaddata</code>命令导入到数据库</li>
</ol>


<p>这样对于大多数场景也算够用了，但是你总会遇到某一天客户走来说：“我想看看那个报表生成出来啥样，能不能创建两千条记录？”</p>

<p>这种时候你大概你第一反应是把之前那个json搞来copy-paste出两千份数据。但很快你就会意识到那是不行的：要构建一个对象，你常常需要先构建它外键的对象，而实际上线的项目它的数据库结构是非常复杂的（数据库结构图的生成见<a href="http://lenciel.cn/2014/12/integrate-schemaspy-with-sphinx-build-for-django-database-design-visualization/">这里</a>），所以构建两千条记录的工作量会远远超过你的想象：</p>

<p><img src="/downloads/images/2014_12/database_design_visualization.png" title="schemaSpy..." alt="schemaSpy" /></p>

<p>最近本座试用了<a href="https://github.com/rbarrois/factory_boy/">factory boy</a>和<a href="https://github.com/joke2k/faker">faker</a>的组合，感觉还比较好用。</p>

<a name="Factory.Boy"></a>
<h2>Factory Boy</h2>

<p>最开始找这类批量生成测试数据的库，主要考察的是<a href="https://github.com/vandersonmota/model_mommy">Model Mommy</a>和<a href="https://github.com/rbarrois/factory_boy/">Factory Boy</a>。看了一下文档感觉两者的差别并不算很大，但是<a href="http://movie.douban.com/subject/1898357/">Factory Girl</a>里面的<a href="http://movie.douban.com/celebrity/1003485/">Sienna Miller</a>实在是让人过目不忘所以有什么好犹豫的呢？</p>

<p>Factories的文档上说明了基本的用法，需要注意的主要是如何生成有一定依赖关系的一组测试对象。</p>

<a name="L............"></a>
<h3>数据构造</h3>

<p>Factory Boy下的数据构造主要是通过<code>Sequence</code>和<code>Fuzz</code>两个包来完成。</p>

<p><code>Sequence</code>故名思议是顺序生成的，比如你要让生成的数据有规律的用户名和电话号码，这样你看到电话<code>13000000001</code>就是是对应<code>user0001</code>：</p>

<pre><code class="python">
user = Sequence(lambda n: u'user%04d' % n)
phone = Sequence(lambda n: u'1300000%04d' % n)
</code></pre>

<p>而<code>Fuzz</code>则是随机的，主要用来构造像学校、专业或者生日这样的数据：</p>

<pre><code class="python">
card_bank = FuzzyChoice([u'中国银行', u'中国招商银行', u'中国工商银行',
                      u'中国建设银行', u'成都银行'])
major = FuzzyChoice([u'地球物理学', u'大气科学', u'海洋科学', u'力学',
                  u'农业工程', u'环境科学', u'心理学', u'统计学',
                  u'系统科学', u'地矿', u'机械', u'仪器仪表',
                  u'能源动力', u'电气信息', u'土建', u'测绘',
                  u'环境与安全', u'化工与制药', u'交通运输', u'海洋工程;',
                  u'航空航天', u'武器', u'工程力学', u'生物工程',
                  u'公安技术', u'材料科学', u'材料', u'水利',
                  u'林业工程', u'轻工纺织食品', u'电子信息科学', u'其他'])
birthday = FuzzyNaiveDateTime(dt.datetime(1992, 1, 1), dt.datetime(1996, 1, 1))
</code></pre>

<p>当然，有的字段，比如姓名、地址这类通过顺序或者是随机的从某个设定的集合抽取效果都不够理想，后面会看到怎么用<a href="https://github.com/joke2k/faker">faker</a>来构造它们。</p>

<a name="L.................."></a>
<h3>关联对象生成</h3>

<p>关联对象的关系有很多种(1:1, 1:n, n:1, n:n)，主要都是通过组合运用<code>SubFactory</code>和<code>RelatedFactory</code>两者来生成，但具体的构造方式和先构造谁都要以实际情况而定。比如我们有User和Tester这样的1:1的关系：</p>

<pre><code class="python">
class Tester(TimeBaseModel):

    user = models.OneToOneField(User,
                                verbose_name=u'账号',
                                related_name='tester')
    ...
</code></pre>

<p>这里在考虑是在<code>TesterFactory</code>里面把<code>User</code>作为<code>SubFactory</code>来生成，还是在<code>UserFactory</code>里面把<code>Tester</code>作为<code>RelatedFactory</code>来生成，主要就是看先后关系。很显然，在这里我们应该先构造系统里的User：</p>

<pre><code class="python">
class TestUserFactory(UserFactory):
    ...
    tester = RelatedFactory('apps.tester.factories.TesterFactory', 'user')
</code></pre>

<p>这段代码告诉系统，在每个<code>TestUser</code>被构造的时候，用构造出来的<code>user</code>来创建一个1:1的<code>Tester</code>。这个<code>Tester</code>的构造会在<code>user</code>的<code>save</code>之前完成。</p>

<p>然后在<code>Tester</code>的构造过程中你可以直接通过<code>SelfAttribute</code>使用传入的<code>user</code>:</p>

<pre><code class="python">
class TesterFactory(DjangoModelFactory):
    ...
    phone = SelfAttribute('user.phone')
    nick_name = SelfAttribute('user.nick_name')
    creator = SelfAttribute('user')
</code></pre>

<p>再比如，我们的<code>Tester</code>和<code>PlatformTask</code>都会关联到测试任务<code>TesterTask</code>，它们俩看起来都是<code>ForeinKey</code>。</p>

<pre><code class="python">
class TesterTask(TestingDeviceMixin, TimeBaseModel):
    owner = models.ForeignKey(Tester,
                              verbose_name=u'测试人', )

    platform_task = models.ForeignKey(PlatformTask,
                                      verbose_name=u'任务',
                                      related_name=u'tester_tasks')
</code></pre>

<p>但对生成数据而言，我们的目标会是每个<code>Tester</code>在被创建的时候，都给它创建一个以这个<code>Tester</code>为<code>owner</code>的<code>TesterTask</code>，并且给这个<code>TesterTask</code>创建一个关联的<code>PlatformTask</code>。</p>

<p>于是我们的写法就会是，首先在<code>TesterFactory</code>里面使用<code>RelatedFactory</code>来创建<code>TesterTask</code>:</p>

<pre><code class="python">
class TesterFactory(DjangoModelFactory):
    ...
    tester_task = RelatedFactory('apps.tester.factories.TesterTaskFactory', 'owner')
    ...
</code></pre>

<p>然后在<code>TesterTaskFactory</code>里面创建<code>PlatformTask</code>，并且在构造的时候使用传入的<code>owner</code>的参数：</p>

<pre><code class="python">
class TesterTaskFactory(DjangoModelFactory):
    ...
    platform_task = SubFactory('apps.platformtask.factories.PlatformTaskFactory',
                               company=SelfAttribute('..owner.user.company'),
                               owner=SelfAttribute('..owner.user'))
    ...
</code></pre>

<a name="faker"></a>
<h2>faker</h2>

<p>有很多字段，比如姓名、地址这些，纯粹用Fuzz的办法很难做到“贴近真实”。<a href="https://github.com/joke2k/faker">faker</a>就是用来解决这类字段的。</p>

<pre><code class="python">
from faker import Factory
fake = Factory.create()

fake.name()
# 'Lucy Cechtelar'

fake.address()
# "426 Jordy Lodge
#  Cartwrightshire, SC 88120-6700"

fake.text()
# Sint velit eveniet. Rerum atque repellat voluptatem quia rerum. Numquam excepturi
# beatae sint laudantium consequatur. Magni occaecati itaque sint et sit tempore. Nesciunt
# amet quidem. Iusto deleniti cum autem ad quia aperiam.
# A consectetur quos aliquam. In iste aliquid et aut similique suscipit. Consequatur qui
# quaerat iste minus hic expedita. Consequuntur error magni et laboriosam. Aut aspernatur
# voluptatem sit aliquam. Dolores voluptatum est.
# Aut molestias et maxime. Fugit autem facilis quos vero. Eius quibusdam possimus est.
# Ea quaerat et quisquam. Deleniti sunt quam. Adipisci consequatur id in occaecati.
# Et sint et. Ut ducimus quod nemo ab voluptatum.
</code></pre>

<p>这个包最可爱的地方就是支持本地化，比如一个随机的中文姓名可以这么去构造：</p>

<pre><code class="python">
faker = FakerFactory.create('zh_CN')
name = lazy_attribute(lambda x: faker.name())
</code></pre>

<a name="L......fixture"></a>
<h2>生成fixture</h2>

<p>因为<a href="https://github.com/rbarrois/factory_boy/">factory boy</a>和<a href="https://github.com/joke2k/faker">faker</a>主要的作用是在测试里面去mock数据，所以要用它们生成fixture不是那么容易。这是因为Django的整个设计上就很注意避免你把测试的数据写到生产的数据库，所以测试都会在一个在<code>Setup</code>阶段被创建，在<code>TearDown</code>阶段被删除的临时数据库里面进行（我看了一下，在开发版本的Django上已经加了一个<code>--keepdb</code>的参数使得你可以<a href="https://docs.djangoproject.com/en/dev/ref/django-admin/#django-admin-option---keepdb">保留你用来运行测试的数据库了</a>）。</p>

<p>所以我们可以在一个测试的<code>Setup</code>阶段把数据生成后，直接调用<code>dumpdata</code>命令来把数据<code>dump</code>出去：</p>

<pre><code class="python">
def setUp(self):
    company = CompanyFactory.create(id=3)
    TestUserFactory.create(company=company, id=3000)
    TestUserFactory.create_batch(company=company, size=1500)

    #for test_user in test_users:

    create_fixture('tester', 'tester.json')
    create_fixture('account', 'account.json')
</code></pre>

<p>注意，这里在创建的时候指定id主要是为了让初始的id比较大，避免和系统里面已经有的id撞车导致你构造的测试数据在<code>loaddata</code>的时候报错或者覆盖现有数据。</p>

<p>其中，<code>create_fixture</code>函数内容如下：</p>

<pre><code class="python">def create_fixture(app_name, filename):
    buf = StringIO()
    management.call_command('dumpdata', app_name, indent=4, stdout=buf)
    buf.seek(0)
    with open(filename, 'w') as f:
        f.write(buf.read().encode('utf-8'))
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Correct Django Site Name During DB Migration]]></title>
    <link href="http://lenciel.cn/2014/11/correct-django-site-name-in-sentry/"/>
    <updated>2014-11-02T16:50:40+08:00</updated>
    <id>http://lenciel.cn/2014/11/correct-django-site-name-in-sentry</id>
    <content type="html"><![CDATA[<p><img src="/downloads/images/2014_11/sentry_incorrect_site.png" title="Don't touch me..." alt="Vhost threshold" /></p>

<a name="Problem"></a>
<h1>Problem</h1>

<p>就像截图上显示的那样，真正上线过的Django项目都会好像被施放过诅咒一般，让你在某一天看到那个诡异的<code>example.com</code>。</p>

<p>它可能是在系统发出去的重置密码的邮件里面，可能是在Sentry显示的日志里面，也可能就在你用 <code>site_name</code> tag渲染的模板里面。</p>

<p>这个诅咒来自于Django的<a href="https://docs.djangoproject.com/en/1.6/ref/contrib/sites/">sites framework</a>的设计。简单来说，它提供了一个Site对象的<code>manager</code>，来<strong>方便</strong>你用一套代码给多个部署环境使用。换句话说，虽然<code>settings.py</code>文件里面也有一个<code>SITE_NAME</code>，但其实用<code>Site.objects.get_current().name</code>或者是模板里面的<code>site_name</code>取到的不是那个值，而是数据库<code>django_site</code>里面某个<code>site_id</code>对应的Site对象的<code>name</code>。</p>

<p>而如果你<code>syncdb</code>之后没有手工修改过，<code>Site</code>的<code>domain</code>和<code>name</code>都被默认初始化为<code>example.com</code>，这就是问题所在了。</p>

<a name="Solution"></a>
<h1>Solution</h1>

<p>stackoverflow上<a href="http://stackoverflow.com/questions/3430451/using-django-settings-in-templates">得票最高的答案</a>这样把<code>site_name</code>放到<code>response</code>的<code>local()</code>里面或者是直接做个<code>context_processor</code>是可以的。但这样的坏处是完全抛弃了Django自带的<code>sites</code>，需要在用的地方都专门的处理。</p>

<p>如果要继续使用自带的<code>sites</code>，就得自己写类似下面的fixture：</p>

<pre><code>[
  {
    "pk": 1,
    "model": "sites.site",
    "fields": {
      "name": "LeiFun Production",
      "domain": "leifun.net"
    }
  },
  {
    "pk": 2,
    "model": "sites.site",
    "fields": {
      "name": "LeiFun Stage",
      "domain": "stage.leifun.net"
    }
  },
  {
    "pk": 3,
    "model": "sites.site",
    "fields": {
      "name": "LeiFun Test",
      "domain": "test.leifun.net"
    }
  },

  {
    "pk": 4,
    "model": "sites.site",
    "fields": {
      "name": "LeiFun Local Dev",
      "domain": "yawp.dev:8000"
    }
  }
]
</code></pre>

<p>然后在部署的环境里面用<code>django_admin.py</code>或者<code>manage.py</code>运行<code>loaddata</code>。这样的坏处是<code>fixture</code>这东西本来主要是给本地测试生成mock数据的，所以<code>syncdb</code>命令其实不会发起fixture的导入，于是很多时候你部署了新版本之后，会忘记重新导入<code>fixture</code>（其实本来也不该导入fixture)，牛皮癣一样的<code>example.com</code>又回来了。</p>

<a name="Solution.2"></a>
<h1>Solution 2</h1>

<p>通过修改某个现成app的<code>Migration</code>类的<code>forwards</code>方法，强制它读取一次<code>settings</code>文件里面的配置项：</p>

<pre><code class="python">class Migration(DataMigration):

    def forwards(self, orm):
        Site = orm['sites.Site']
        site = Site.objects.get(id=settings.SITE_ID)
        site.domain = settings.DOMAIN_NAME
        site.name = settings.SITE_NAME
        site.save()
</code></pre>

<p>这样一来，就可以在<code>syncdb</code>的时候刷新<code>django_site</code>这张表的配置。</p>

<a name="Solution.Finally"></a>
<h1>Solution Finally</h1>

<p>在Django 1.7里面，这个倒霉的设计<a href="https://docs.djangoproject.com/en/dev/ref/contrib/sites/?from=olddocs">终于被改掉了</a>。</p>

<p><blockquote><p>To enable the sites framework, follow these steps:</p></p><p><ol><br/><li>Add &lsquo;django.contrib.sites&rsquo; to your INSTALLED_APPS setting.</li><br/><li>Define a SITE_ID setting</li><br/><li>Run migrate.</li><br/></ol></p><p><br/><p>django.contrib.sites registers a post_migrate signal handler which creates a default site named example.com with the domain example.com. This site will also be created after Django creates the test database. To set the correct name and domain for your project, you can use a data migration.</p></blockquote></p>

<p>不但如此，Django 1.7 还引入了<code>django.contrib.sites.middleware.CurrentSiteMiddleware</code>， 如果启用，就可以直接使用<code>request.site</code>而不需要在你的<code>view</code>里面自己去调用<code>site = Site.objects.get_current()</code>了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Data Migration in Django 1.7 (2)]]></title>
    <link href="http://lenciel.cn/2014/08/django-1-dot-7-migrations-part-2/"/>
    <updated>2014-08-11T03:59:47+08:00</updated>
    <id>http://lenciel.cn/2014/08/django-1-dot-7-migrations-part-2</id>
    <content type="html"><![CDATA[<p>在应用开发的过程中，我们会遇到migration主要分为：</p>

<ol>
<li>Schema Migrations：数据库schema的变化，也就是我们前面<a href="http://lenciel.cn/2014/08/django-1-dot-7-migrations/">讨论的内容</a></li>
<li>Data Migrations：数据的变化，比如需要批量变更数据或者备份在其他地方的历史数据</li>
</ol>


<p>第二种是没法敲几条命令让Django自动帮你完成其他的事情的，而是需要手动使用<code>RunPython</code>，这里具体说一下做法。</p>

<p>还是以之前的那个项目来作为例子，我们首先创建一个migration file：</p>

<pre><code class="bash">$ python manage.py makemigrations --empty ts_data

Migrations for ts_data:
  0003_auto_20140811_0110.py:
</code></pre>

<p>它的内容如下：</p>

<pre><code class="python"># -*- coding: utf-8 -*-
from __future__ import unicode_literals

from django.db import models, migrations


class Migration(migrations.Migration):

    dependencies = [
        ('ts_data', '0002_auto_20140805_1525'),
    ]

    operations = [
    ]
</code></pre>

<p>我们在里面加入一个<code>RunPython</code>的部分，来导入数据：</p>

<pre><code class="python"># -*- coding: utf-8 -*-
from __future__ import unicode_literals

from django.db import models, migrations
from ts_data.models import PingPongPrice


def load_data(apps, schema_editor):
    PingPongPrice(date=date(2014,07,29),
         price=12.00,
         ).save()
    PingPongPrice(date=date(2014,01,29),
         price=8.00,
         ).save()


class Migration(migrations.Migration):

    dependencies = [
        ('ts_data', '0002_auto_20140805_1525'),
    ]

    operations = [migrations.RunPython(load_data)]
</code></pre>

<p>如果你觉得：咦，这样导入数据不是有点儿像用<code>syncdb</code>然后导入<code>fixture</code>么？的确，从效果上它们是一样的，个人觉得，对于测试环境我们可以继续使用fixture来保存mock的测试数据，然后使用<code>loaddata</code>命令手动加载测试数据。对生产环境使用migration来导入数据更好，和使用<code>loaddata</code>命令来导入fixture相比，它不需要手动操作，并且由于是通过<code>RunPython</code>来进行，实际上可以对数据进行各种需要的处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Data Migration in Django 1.7 (1)]]></title>
    <link href="http://lenciel.cn/2014/08/django-1-dot-7-migrations/"/>
    <updated>2014-08-05T11:12:41+08:00</updated>
    <id>http://lenciel.cn/2014/08/django-1-dot-7-migrations</id>
    <content type="html"><![CDATA[<p>Django 1.7已经发布一段时间了，基本上这个版本最主要的改动就是加入了<code>migrations</code>。</p>

<p>在过去，几乎所有的Django项目都是用South来处理数据变更的。而在Django1.7版本，South的作者Andrew Godwin把<code>migrations</code>加到了Django Core里面。</p>

<p>So&hellip;</p>

<a name="Migrations............"></a>
<h1>Migrations是什么？</h1>

<p>Migrations其实就是一堆帮助你完成数据库变更和数据迁移的命令，使得你可以用“Django”的方式来管理和变更数据库的schema。比如，当你的model改变了，你需要在数据库里面去重命名一列时，你不会想跑到命令行下面去敲SQL吧？特别是，如果你要变更的数据库是线上的，有几百万用户数据，你应该更不愿意搭上这种活了吧？</p>

<p>Migrations让事情变得简单可控：</p>

<ol>
<li>它使得数据库schema的调整可以通过Django命令来完成</li>
<li>它使得数据库的schema和对应的model的变更被track起来：整个历史都可以版本化在Git里面</li>
<li>提供了一套匹配schema和对应的fixture的机制</li>
<li>如何和CI搭配起来，可以保证代码和数据一致性</li>
</ol>


<a name="Migrations......"></a>
<h1>Migrations上手</h1>

<a name="L.................."></a>
<h2>创建测试项目</h2>

<p>首先创建一个virtualenv和django项目：</p>

<pre><code class="bash">$ mkvirtualenv django17
$ pip install https://www.djangoproject.com/download/1.7c2/tarball/
$ django-admin.py startproject django_migration_test
$ cd django_migration_test
$ python manage.py startapp ts_data
</code></pre>

<p>然后创建一个model到subl ts_data/models.py：</p>

<pre><code class="python">from django.db import models

# Create your models here.
class PingPongPrice(models.Model):
    date = models.DateTimeField(auto_now_add=True)
    price = models.DecimalField(max_digits=5, decimal_places=2)
</code></pre>

<p>subl django_migration_test/settings.py</p>

<pre><code class="python">INSTALLED_APPS = (
    ...
    'ts_data',
)
</code></pre>

<a name="L......Migrations"></a>
<h2>创建Migrations</h2>

<p>使用下面的命令可以创建ts_data这个app的Migrations。当然，和大多数Django命令一样，如果你不显式的指定，就</p>

<pre><code>(django17) ○ python manage.py makemigrations ts_data
Migrations for 'ts_data':
  0001_initial.py:
    - Create model PingPongPrice
</code></pre>

<a name="L......Migrations"></a>
<h2>应用Migrations</h2>

<pre><code class="bash">(django17) ○ python manage.py migrate
Operations to perform:
  Apply all migrations: admin, contenttypes, ts_data, auth, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying sessions.0001_initial... OK
  Applying ts_data.0001_initial... OK
</code></pre>

<p>注意，因为是一个全新的app，这条命令会先建表，换句话说，之前版本的<code>syncdb</code>命令可以不用了。整个使用流程应该变成：</p>

<ol>
<li>建立或者更新一个model</li>
<li>运行<code>python manage.py makemigrations &lt;app_name&gt;</code></li>
<li>运行<code>python mange.py migrate &lt;app_name</code>来应用创建的Migrations</li>
<li>重复前面的步骤</li>
</ol>


<a name="L................................."></a>
<h1>不是新建的项目如何使用</h1>

<p>大多数情况下我们都是从旧版本的Django迁移过来，也就意味着是从South迁移过来。这种情况下需要：</p>

<ol>
<li>删除所有的South创建的migration文件</li>
<li>运行 <code>./manage.py makemigrations</code>，Django会根据你当前model来创建那份<code>initial migrations file</code></li>
<li>运行<code>./manage.py migrate</code>，Django会把已经存在的数据库table当成是migration的产物，完成整个migration</li>
</ol>


<p>如果你运行上面的命令遇到错误，就需要运行 <code>./manage.py migrate --fake &lt;appname&gt;</code> 做一个fake的migration。</p>

<p>如果你不想丢掉过去的South维护的历史记录，可以同时使用South和Django Migrations：升级South到1.0，然后<a href="http://www.aeracode.org/2014/7/1/end-era/">参考这篇文章的做法</a>。</p>

<a name="South...Django.Migrations......"></a>
<h1>South和Django Migrations比较</h1>

<p>对比一下South和Django Migrations的workflow，可能会更加清晰：</p>

<a name="L............migrations"></a>
<h2>首次全新migrations</h2>

<p>South:</p>

<pre><code class="python">./manage.py syncdb
./manage.py schemamigration &lt;appname&gt; --initial
</code></pre>

<p>Django Migrations:</p>

<pre><code class="python">./manage.py makemigrations &lt;appname&gt;
</code></pre>

<a name="L......migrations"></a>
<h2>应用migrations</h2>

<p>South:</p>

<pre><code class="python">./manage.py migrate &lt;appname&gt;
</code></pre>

<p>Django Migrations:</p>

<pre><code class="python">./manage.py migrate &lt;appname&gt;
</code></pre>

<a name="L.........migrations"></a>
<h2>非首次migrations</h2>

<p>South:</p>

<pre><code class="python">./manage.py schemamigration &lt;appname&gt; --auto
</code></pre>

<p>Django Migrations:</p>

<pre><code class="python">./manage.py makemigration &lt;appname&gt;
</code></pre>

<p>可以看到，大概是因为出自同一个作者的原因，Django Migrations基本上follow了South的工作流程，只不过是命令更加简洁和清晰了。</p>

<a name="L............"></a>
<h1>更多细节</h1>

<a name="L..................Django.Migrations........."></a>
<h2>哪些变化会被Django Migrations找到？</h2>

<p>如果你再次运行<code>python manage.py migrate</code>，会发现什么都没有发生：这是因为在项目的数据库中有一张<code>django_migrations</code>仍然被更新。表，记录了哪些Migrations已经被应用过了：无论是运行了migrate还是fake的，这个表都会被插入一条记录。比如从South升级到使用Django自带的MigrationsDjango会检查是否有更新。如果没有，它就fake一次，但<code>django_migrations</code>仍然被更新。</p>

<p>在少数情况下，确实有需要再次运行某个特定的Migrations，我们可以在<code>django_migrations</code>里面把这个记录删除掉。</p>

<p>在极少数情况下，如果你有需要回退到特定的版本，比如最初的zero版本，可以用类似<code>python manage.py migrate &lt;app_name&gt; zero</code>的语法。</p>

<a name="Migration......."></a>
<h2>Migration 文件</h2>

<p>在我们运行<code>python manage.py migrate &lt;app_name&gt;</code>究竟发生了什么？实际上，Django会创建一个python文件来描述如何完成这个migration，以前面的ts_data为例，这个文件位于<code>ts_data/migrations/0001_initial.py</code>，内容如下：</p>

<pre><code class="python"># -*- coding: utf-8 -*-
from __future__ import unicode_literals

from django.db import models, migrations


class Migration(migrations.Migration):

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='PingPongPrice',
            fields=[
                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),
                ('date', models.DateTimeField(auto_now_add=True)),
                ('price', models.DecimalField(max_digits=5, decimal_places=2)),
            ],
            options={
            },
            bases=(models.Model,),
        ),
    ]
</code></pre>

<p>可以看到，是完全可读的Python代码。这也是为什么推荐把整个<code>migrations</code>文件夹加入版本控制的原因：这样你的应用经过了怎样的变更就变得可以回溯了。</p>

<a name="Migration.Dependencies"></a>
<h2>Migration Dependencies</h2>

<p>上面的源代码有一些值得注意的地方。</p>

<p>首先，所有的migration file里面都有一个<code>Migration()</code>类，继承自<code>django.db.migrations.Migration</code>。在我们运行<code>migrate</code>命令的时候，运行的就是这个类。</p>

<p>这个类有两个list，一个是<code>dependencies</code>，一个是<code>operations</code>。</p>

<p><code>dependencies</code>定义了这个migration之前必须完成的操作，比如你的model里面包括一个外键，那么你得首先有对应的table。比如，假设外键指向的model在<code>app_1</code>，那么<code>dependencies</code>会像这样：</p>

<pre><code class="python">dependencies = [
   ('main', '__first__'),
]
</code></pre>

<p>如果没有前置条件，这个list可以为空。但大多数时候<code>dependencies</code>是指向其他的migration文件。比如：</p>

<pre><code class="python">dependencies = [
    ('main', '0001_initial'),
]
</code></pre>

<p>这里使用list的结果是，所有的依赖是没有顺序的，也就是说你不需要按照0001、0002、0003的顺序来排列所有的依赖。</p>

<a name="Migration.Operations"></a>
<h2>Migration Operations</h2>

<p>这个list定义的就是migration完成的操作，可以分为下面的这些种类：</p>

<ul>
<li>CreateModel</li>
<li>DeleteModel</li>
<li>RenameModel</li>
<li>AlterModelTable</li>
<li>AlterUniqueTogether</li>
<li>AlteIndexTogether</li>
<li>AddField</li>
<li>RemoveField</li>
<li>RenameField</li>
<li>RunSQL</li>
<li>RunPython</li>
</ul>


<p>前面的那些操作是整个Django Migrations的核心：因为需要对各种不同的数据库做适配。而后面的两个操作则是灵活度非常高的，几乎可以干任何事情。</p>

<a name="L......"></a>
<h1>实例</h1>

<p>让我们试试把<code>PingPongPrice</code>的<code>price</code>这个field的<code>max_digits</code>改成8位的（通货膨胀嘛），然后再次运<code>makemigrations</code>行命令:</p>

<pre><code class="bash">(django17) ○ python manage.py makemigrations ts_data
Migrations for 'ts_data':
  0002_auto_20140805_1525.py:
    - Alter field price on PingPongPrice
</code></pre>

<p>可以看到这次生成的migration文件里面有<code>AlterField</code>操作：</p>

<pre><code class="python"># -*- coding: utf-8 -*-
from __future__ import unicode_literals

from django.db import models, migrations


class Migration(migrations.Migration):

    dependencies = [
        ('ts_data', '0001_initial'),
    ]

    operations = [
        migrations.AlterField(
            model_name='PingPongPrice',
            name='price',
            field=models.DecimalField(max_digits=8, decimal_places=2),
        ),
    ]
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[uWSGI, Gunincorn, 啥玩意儿?]]></title>
    <link href="http://lenciel.cn/2013/08/why-you-need-something-like-gunicorn/"/>
    <updated>2013-08-01T14:36:00+08:00</updated>
    <id>http://lenciel.cn/2013/08/why-you-need-something-like-gunicorn</id>
    <content type="html"><![CDATA[<p>因为nginx等优秀的开源项目，有不少本来不是做服务器的同学也可以写很多服务器端的程序了。但是在聊天中会发现，大家虽然写了不少代码，但是对wsgi是什么，gunicorn是什么，反向代理又是什么并不了解，也就是说对基本概念并没有一个全局的了解。</p>

<a name="L........."></a>
<h3>服务器</h3>

<p>到了服务器组你会发现原来有各种各样的服务器，那些叫法很多是有历史沉淀的，不需要太深究能对上号就行，因为本来也是乱七八糟的。</p>

<a name="HTTP........."></a>
<h4>HTTP服务器</h4>

<p>如果网站是HTML/CSS/JS（不包括node.js这种<a href="http://en.wikipedia.org/wiki/Comparison_of_server-side_JavaScript_solutions">SSJS</a>）组成的，那么这是一个静态的网站。</p>

<p>用户访问这个网站的时候，HTTP请求被浏览器发送，经过DNS等被送到网站的服务器。服务器处理HTTP请求，将浏览器能够处理的响应返回给用户的浏览器。所以这个场景下的服务器一般被称为HTTP服务器，常见的有Apache的httpd和Nginx。</p>

<a name="Application........."></a>
<h4>Application服务器</h4>

<p>如果你的网站是动态的，比如是用Django写的。</p>

<p>那么客户端上来的请求要能够被Djano的Application处理。WSGI就是这样的<a href="http://en.wikipedia.org/wiki/Web_Server_Gateway_Interface">一个协议</a>：它是一个Python程序和用户请求之间的接口。WSGI服务器的作用就是接受并分析用户的请求，调用相应的python对象完成对请求的处理，然后返回相应的结果。</p>

<p>WSGI服务器的选择很多，包括uWSGI和gunicorn。它们都可以处理所有的请求，包括确实应该由python对象处理的，也包括不该python对象处理的，比如静态的图像，css，js等文件。所有理论上你可以把整个动态网站都用WSGI服务器承载起来，也就是整个应用完全跑在Application服务器上。</p>

<a name="L..............."></a>
<h4>代理服务器</h4>

<p>代理无非是A来做B干的事情。在服务器语境下，代理就是一台服务器干另外一台服务器的事情。这个是平常不会有很多人聊到的，多说两句。</p>

<a name="L....................."></a>
<h5>前向代理服务器</h5>

<p>大多数的代理都是前向代理。假设网络上有三台机器:</p>

<ul>
<li>X：你的电脑</li>
<li>Y：代理服务器，proxy.eg.org</li>
<li>Z：你实际想访问的服务器，www.eg.org</li>
</ul>


<p>没有代理的情况下，访问是 <code>X---&gt;Z</code>，但是在某些情况下，访问者会先让代理服务器从实际放内容的服务器把数据取回来，也就是<code>X---&gt;Y</code>，然后<code>Y----&gt;Z</code>，最后<code>X----&gt;Y</code> 。</p>

<p>这里说的某些情况下典型的包括（作为天朝网民你居然没有领悟我很失望）：</p>

<ol>
<li>X的网络管理员封了Z</li>
<li>Z可能是一个臭名昭著的病毒网站：<code>familypostcard2008.com</code>等</li>
<li>Z可能是一个让你上班精力分散的网站：<code>Facebook.com</code>等</li>
<li><p>Z可能是一个让你明白真相的网站：Hmmmm</p></li>
<li><p>Z的网络管理员封了X</p></li>
<li>Z可能是一个论坛或者blog什么的，X在对它进行扫描</li>
</ol>


<a name="L....................."></a>
<h5>反向代理服务器</h5>

<p>没有代理的情况下，访问仍然是 <code>X---&gt;Z</code>，但是在某些情况下，Z的管理者决定限制资源被直接访问。用户必须现在Y上做访问，Y再访问Z。整个流程是<code>X---&gt;Y</code>，然后<code>Y----&gt;Z</code>，最后<code>X----&gt;Y</code> 。</p>

<p>没错，细心的你注意到了，前向和反向代理服务器的流程都是<code>X--&gt;Y--&gt;Z</code>。没办法，代理就是这么个意思。它们两者的核心区别在于，用户对反向代理服务器的存在是无感的。换句话说，X不需要做特别的配置甚至不需要察觉Y的存在，就可以使用Y这个反向代理。这种请求方无感而被请求方反过来提供代理服务就是“反向”的意义所在。</p>

<p>使用反向代理的典型场景当然是Z希望所有发给自己特定请求都从Y过一遍：</p>

<ol>
<li>Z可能是一个超大的网站，每天有全世界各地的用户在访问。于是Z搭建了一个反向代理，把某个地域的用户的访问导入到离他最近的服务器上去处理。没有错，这就是CDN。</li>
<li>Z可能是一个坏坏的网站。它的拥有者希望把坏坏的数据放到特定的服务器，然后核心数据放到别的服务器。比如黄色网站，一般那些色情的内容放在一些专门的服务器上，即使被查封，也不会对其业务产生决定性的影响。</li>
</ol>


<p>继续我们前面的例子，很快你会发现uWSGI等应用服务器处理静态文件的请求的performance很废材，于是开始寻找直接用nginx来处理静态内容的办法。那么你就需要区分哪些请求是请求的静态页面，哪些是请求的动态内容。</p>

<p>然后你就会发现，原来nginx不止是一个HTTP服务器，它还是一个<a href="http://en.wikipedia.org/wiki/Reverse_proxy">反向代理服务器</a>：它可以把请求重定向到uWSGI或者任何别的服务器，然后把下游服务器的响应集成再返回给用户。于是你就可以配置对静态内容的请求直接在nginx完成，而动态内容的请求发送给uWSGI服务器。</p>

<a name="L....................."></a>
<h4>负载均衡服务器</h4>

<p>在我自己的心中，负责均衡服务器不过是反向代理的一种（你看CDN我也觉得是反向代理的一种），但是很多地方这种服务器是被拿出来专门讨论的。</p>

<p>随着你的网站访问量不断增大，你用一个nginx集中所有的请求再分发就显得性能不够了。这个时候你可以配置专门用于进行请求分发处理的负载均衡服务器，比如<a href="http://haproxy.1wt.eu/">HAProxy</a>，而负载均衡服务器背后是集群。</p>

<a name="L..............."></a>
<h4>缓存服务器</h4>

<p>随着网站访问量的继续增大，你的VPS流量又扛不住了。你调查发现有一些多媒体文件被经常请求，这个时候你部署了缓存服务器。</p>

<p>&ldquo;缓存&#8221;这个经常被提到的术语，核心就是把常用的信息放在一个读取成本很低地方(比如内存中或者是虚拟内存中），从而避免每次查找它的时候昂贵的操作。比如HTTP缓存解决的是在服务器上找信息的过程。而Redis或者Memcached这些缓存则是解决在数据库里面找信息的过程。
面。</p>

<a name="L...........................uwsgi......gunicorn."></a>
<h3>那，我们为什么需要uwsgi或者gunicorn?</h3>

<p>一句话：因为你需要有东西在服务器上运行Python，但是Python不是处理所有的请求都很强。</p>

<p>那么是选uWSGI还是Gunicorn？我觉得都可以，还是那句老话，不是它们好不好的问题，是你够不够好的问题，毕竟代码都摆在那里的。</p>

<p>不过Gunicorn可以多说几句。它的崛起在我看来是有时代背景的：在过去，我们部署一个应用的时候，几乎总是要分布在多台机器的（比如4台HTTP服务器把动态请求分发到两台Application服务器上，并且它们都访问一个数据库服务器）。但是随着机器的能力在增强，而互联网应用的覆盖面从业务逻辑极其复杂的银行业电信业到了送盒饭选泡面的小行业，越来越多的Application服务器和Web服务器合体了（以django圈子举例，有httpd+mod_wsgi或者Nginx+mod_uwsgi）。而且很多时候这种小应用的数据库也host在同一台机器上。</p>

<p>Gunicorn（从Ruby下面的Unicorn得到的启发）应运而生：依赖Nginx的代理行为，同Nginx进行功能上的分离。由于不需要直接处理用户来的请求（都被Nginx先处理），Gunicorn不需要完成相关的功能，其内部逻辑非常简单：接受从Nginx来的动态请求，处理完之后返回给Nginx，由后者返回给用户。</p>

<p>由于功能定位很明确，Gunicorn得以用纯Python开发：大大缩短了开发时间的同时，性能上也不会很掉链子。同时，它也可以配合Nginx的代理之外的别的Proxy模块工作，其配置也相应比较简单。</p>

<p>配置上的简单，大概是它流行的最大的原因。</p>

<a name="Good.Refs"></a>
<h3>Good Refs</h3>

<a name="L..........................."></a>
<h4>正向代理服务器软件</h4>

<ul>
<li><a href="http://www.jmarshall.com/tools/cgiproxy/">cgi-proxy</a></li>
<li><a href="http://sourceforge.net/projects/poxy">phproxy</a> (中断了)</li>
<li><a href="http://www.glype.com/">glype</a></li>
<li><a href="http://en.cship.org/wiki/Category%3aWebproxy">Internet censorship wiki: List of Web Proxies</a></li>
</ul>


<a name="L..........................."></a>
<h4>反向代理服务器软件</h4>

<ul>
<li><a href="http://wiki.apache.org/cocoon/ApacheModProxy">apache mod_proxy</a></li>
<li><a href="http://www.squid-cache.org/">squid</a></li>
<li><a href="http://nginx.net/">HAProxy</a></li>
<li><a href="http://www.danga.com/perlbal/">perlbal</a></li>
<li><a href="http://portfusion.sf.net/">portfusion</a></li>
<li><a href="http://www.apsis.ch/pound/">pound</a></li>
</ul>


<a name="TCP................................."></a>
<h4>TCP上的反向代理服务器软件</h4>

<ul>
<li><a href="http://www.inlab.de/balance.html">balance</a></li>
<li><a href="http://www.delegate.org/delegate/nvproxy/">delegate</a></li>
<li><a href="http://siag.nu/pen/">pen</a></li>
<li><a href="http://portfusion.sf.net/">portfusion</a></li>
<li><a href="http://web.archive.org/web/20080113185334/http://plb.sunsite.dk/index.html">pure load balancer</a></li>
<li><a href="http://pythondirector.sourceforge.net/">python director</a></li>
</ul>


<a name="L......"></a>
<h4>其他</h4>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Content_Delivery_Network">Wikipedia - Content Delivery Network</a></li>
<li><a href="http://en.wikipedia.org/wiki/Category%3aReverse_proxy">Wikipedia - Category:Reverse_proxy</a></li>
<li><a href="http://en.wikipedia.org/wiki/Load_balancing_%28computing%29">Wikipedia - Load Balancing</a></li>
<li><a href="http://en.wikipedia.org/wiki/Scalability">Wikipedia - Scalability</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
